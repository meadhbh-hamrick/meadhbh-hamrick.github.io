<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta name="description" content="Nano-Blog archive for the week of February 25th, 2024."/>
    <link rel="stylesheet" type="text/css" href="index.css"/>
    <title>Nano Blog (Week of February 25th, 2024)</title>
    <meta charset="utf-8"/>
  </head>
  <body>
    <div id="content">

      <section id="intro">
        <h1>Nano-Blog (Week of February 25th, 2024)</h1>
      </section>

      <section id="blag">
        <a name="2024-03-01"></a>
        <a class="day" href="archive-2024-02-25.html#2024-03-01"><h2>March 1st, 2024 [Friday]</h2></a>

        <a name="2024-03-01-01"></a>
        <p class="fill">
          In the early 90s I worked at <a href="https://en.wikipedia.org/wiki/Convex_Computer">Convex Computer Corporation</a>.
          It was a great place to work, filled with interesting people and cool ideas.
          One of the things I was introduced to there was the programming language/environment <a href="https://en.wikipedia.org/wiki/Self_(programming_language)">Self</a>.
          Now known mainly as a foot-note in the history of JavaScript, Self is best known for popularizing <a href="https://en.wikipedia.org/wiki/Prototype-based_programming">prototypal inheritance</a>.
        </p>

        <p>
          I just discovered a video of Randy Smith and David Ungar's presentation on Self from the <a href="https://dl.acm.org/doi/proceedings/10.1145/1238844">History of Programming Languages III</a> conference is available here: <a href="https://dl.acm.org/doi/10.1145/1238844.1238853">https://dl.acm.org/doi/10.1145/1238844.1238853</a>.
        </p>

        <p>
          More information about Self can be found at <a href="https://selflanguage.org/">https://selflanguage.org/</a>.
          I was able to download the 2017.1 release and get it running on a Ubuntu 22.04.4 without too much trouble.
        </p>

        <p>
          My favourite quote from the presentation is Randy Smith emphasizing <i>...broad explanatory power coming from a few simple principles.</i>
          Like Lisp and Smalltalk, Self takes a few powerful abstractions and uses them to do everything in the language.
          Well worth the time if you're curious about what Smalltalk evolved into and some of what JavaScript evolved from.

          <a href="hash-s.html#self">#self</a>
          <a href="hash-p.html#programming">#programming</a>
          <a href="archive-2024-02-25.html#2024-03-01-01">[permalink]</a>
        </p>

        <a name="2024-02-29"></a>
        <a class="day" href="archive-2024-02-25.html#2024-02-29"><h2>February 29th, 2024 [Thursday]</h2></a>

        <a name="2024-02-29-01"></a>
        <p class="fill">
          People who know me know I'm a fan of <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">the Lisp familiy of programming languages.</a>
          Whether it's Common Lips, Scheme, Clojure or Janet, I love them all.
          But there's a class of Lisp interpreters which are mostly used to demonstrate how to build a Lisp interpreter.
          Worth checking out if you've ever wondered what was going on under the hood of your favourite lisp.

          <ul>
            <li><a href="https://github.com/Robert-van-Engelen/tinylisp">Lisp in 99 lines of C and how to write one yourself</a> [Github]</li>
            <li><a href="https://github.com/rxi/fe">fe</a> (a simple, embeddable lisp written in C) [Github]</li>
            <li><a href="https://www.buildyourownlisp.com/">Daniel Holden's "Build Your Own Lisp" book</a></li>
          </ul>

          <a href="hash-l.html#lisp">#lisp</a>
          <a href="hash-p.html#programming">#programming</a>
          <a href="archive-2024-02-25.html#2024-02-29-01">[permalink]</a>
        </p>

        <hr/>

        <a name="2024-02-29-02"></a>
        <p class="fill">
          Speaking of Lisp, I went digging for <a href="https://hackaday.com/2023/07/10/microlisp-lisp-for-microcontrollers-now-has-lisp-based-arm-assembler/">this article from Hackaday</a> which touches on the microlisp ARM assembler.
          They defined a lisp-based assembler which will assemble ARM assembly in the middle of an interpreted lisp program, place it in memory and then let you call it like a normal function.
          The article reports a speed-up of a Fibbonacci sequence calculation from 24.6 seconds to 61 milliseconds.

          And I guess I should mention a couple more related lisps:

          <ul>
            <li><a href="https://github.com/carld/micro-lisp">micro-lisp</a> [GitHub]</li>
            <li><a href="http://www.ulisp.com/">uLisp : Lisp for MicroControllers</a></li>
            <li><a href="https://github.com/technoblogy/ulisp">uLisp source repo</a> [GitHub]</li>
          </ul>

          <a href="hash-l.html#lisp">#lisp</a>
          <a href="hash-p.html#programming">#programming</a>
          <a href="archive-2024-02-25.html#2024-02-29-02">[permalink]</a>
        </p>

        <a name="2024-02-28"></a>
        <a class="day" href="archive-2024-02-25.html#2024-02-28"><h2>February 28th, 2024 [Wednesday]</h2></a>

        <a name="2024-02-28-01"></a>
        <p class="fill">
          I recently spotted this link on Hacker News: <a href="http://www.6502.org/source/interpreters/sweet16.htm">Porting Sweet 16</a> by Carsten Strotmann.
          "Sweet 16" is a virtual machine developed by Steve Wozniak to make working with 16-bit values on the 8-bit Apple II a bit easier.
          Wozniak authored a pair of articles for <i>Byte Magazine</i> in 1977 describing the Apple II and the Sweet 16 meta-processor:

          <ul>
            <li><a href="https://archive.org/details/byte-magazine-1977-05/page/n35/mode/2up">The Apple II</a> [BYTE, May 1977]</li>
            <li><a href="https://archive.org/details/byte-magazine-1977-11/page/n147/mode/2up">SWEET16: The 6502 Dream Machine</a> [BYTE, November 1977]</li>
          </ul>

          <a href="hash-r.html#retrocomputing">#retrocomputing</a>
          <a href="hash-r.html#apple%20ii">#apple ii</a>
          <a href="hash-p.html#programming">#programming</a>
          <a href="archive-2024-02-25.html#2024-02-28-01">[permalink]</a>
        </p>

        <hr/>

        <a name="2024-02-28-02"></a>
        <p class="fill">
          In 1985, Todd Rundgren's <a href="https://en.wikipedia.org/wiki/A_Cappella_(Todd_Rundgren_album)">A Cappella</a> was my favourite album.
          Using only his voice and a sampling synthesizer, he crafted a work emotional depth and technical mastery.
          Rundgren recently sat down to talk about the album and it's production with Gregg Bendian, Andre Cholmondeley and Anthony Garone.
          <a href="hash-m.html#music">#music</a>
          <a href="archive-2024-02-25.html#2024-02-28-02">[permalink]</a>
        </p>

        <iframe width="100%" height="315" src="https://www.youtube-nocookie.com/embed/RRTDlnjVM1o?si=Bt8F8AE0FErMV53m" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

        <hr/>

        <p>
          <a href="archive-2022-05-22.html">Click here to see the previous week (May 22nd, 2022).</a>
        </p>
      </section>

      <section id="footer">
        <p class="fill">
          This page was last updated on May 29, 2024.
          It is part of <a href="index.html">Meadhbh Hamrick's Nano-Blog</a>.
        </p>
      </section>
    </div>
  </body>
</html>
