<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" type="text/css" href="../../css/index.css"/>
    <title>In Defense of BASIC</title>
    <meta charset="utf-8"/>
    <meta name="description" content="People like to pick on COBOL, but they've completely forgotten BASIC."/>
  </head>
  <body class="content">
    <title>In Defense of BASIC</title>

    <section>
      
      <p>
        We frequently judge old technology unfairly because
        we do not account for the user or technical
        environment at the time. Classic BASIC is
        considered a "bad" programming language because it
        has line numbers, no local variables, spotty
        support for user defined functions, no user defined
        data structures and largely implementation specific
        I/O.
      </p>

      <p>
        What we forget is BASIC was designed for mainframe
        systems of the 1960s. And its original objective
        was to teach programming to "non mathematical"
        users (not to write commercial software.)
      </p>

      <p>
        We also forget that in the 1970s, microcomputers
        were frail little things with unimaginably small
        memories. Yes, it would be nice to program my ZX80
        in LISP, but I'm not sure I could fit a LISP
        interpreter in the 1Kb of memory that came with
        it. And the same goes for Haskell, JavaScript, Lua,
        Python, PERL, PHP and even C++. We have reasonably
        good optimizing C compilers for 8-bit micros today,
        but they didn't start appearing until the '90s. And
        in the late '70s or early '80s, you would have had
        to have access to a minicomputer to run the
        compiler; self-hosting C compilers really weren't a
        thing until 16 and 32 but micros emerged in the
        1980s.
      </p>

      <p>
        If you wanted to write code on a classic 8-bit
        micro, your primary choices were: assembly
        language, FORTH, BASIC or UCSD Pascal. And Pascal
        might not have really counted because it required
        SO MUCH MEMORY! (I think it required 48k of RAM on
        the Apple II.) FORTH was a capable language, but
        it's stack-based reverse-polish syntax confused
        more than a few people. As an industry we wanted to
        make computers seem as user friendly as possible,
        and telling people they had to write programs in
        assembly language would fail miserably at this
        goal.
      </p>

      <p>
        So this left BASIC. And had it not been BASIC, it
        would have been some other language like BASIC:
        byte-code interpreted, limited or no local
        variables, limited or no data structures, etc.
      </p>

      <p>
        But the most important feature of early 8-bit
        micros is they booted into BASIC. You turned on the
        machine and in a few seconds, you got the welcoming
        "READY" prompt. There was no command line or shell,
        there was a programming language. And it usually
        booted pretty fast, within five seconds of turning
        on the power. You went from "off" to "programming"
        in five seconds or less.
      </p>

      <p>
        Neal Stephenson once wrote "In the Beginning was
        the Command Line," and that's probably true for
        mini-computers, but for micros, the command line
        came after we were ejected from the algorithmic
        Eden of the BASIC interpreter.
      </p>

      <p>
        Modern audiences might find it odd to boot a
        computer into a programming language (and a
        programming language with as many limitations as
        BASIC.) But at the time it seemed natural. What do
        computers do? They compute. How do we tell them
        what to compute? With programs! And micro-computer
        vendors of the late '70s believed their systems
        would be programmed by the same people who bought
        the system.
      </p>

      <p>
        This sort of made sense in the 1970s. Apart from a
        few applications where micro-computers replaced
        complex logic assemblies in manufacturing and
        scientific applications, they started as hobbyist
        curiosities. Early adopters (like myself)
        immediately saw some application in their personal
        lives. I used a computer to calculate where I
        should point a telescope for maximal enjoyment of
        Messier objects. A friend used his Apple II to
        control a series of spinning prisms and replicated
        the laser light shows he had seen at the local
        planetarium.
      </p>

      <p>
        Micro-computer business tycoons (Steve Jobs being
        the most obvious) figured out corporate early
        adopters were using micros to dis-intermediate
        corporate data processing groups. Booting systems
        into BASIC let these corporate pioneers start quick
        with the business of thumbing their nose at the
        corporate data processing groups who often charged
        obscene amounts of "internal corporate funny-money"
        to sort a data set or perform simple
        calculations. In the late 1970s you didn't have a
        computer to play Mario-Cart or send email. You had
        a computer to solve one or two specific real-world
        problems or maybe you were a geek who liked to play
        with technology (or both.)
      </p>

      <p>
        VisiCalc would eventually come along in '79 and
        kick-start the commercial Independent Software
        Vendor (ISV) market for small computers. But even
        VisiCalc was a programming language of sorts; just
        one with a highly constrained user interface. But
        it took another five years or so for the "Boot to
        BASIC" concept to eventually die off. By that time
        16 and 32 bit systems were starting to gain
        traction in the market. The Macintosh demonstrated
        what a computer could be (though it was still
        horribly expensive.) Jack Tramiel's 8-bit commodore
        line lasted throughout the '80s as the "computer
        for the masses, not the classes." If you didn't
        have the cash for a Macintosh, Amiga or Atari
        520ST, you could always pick up a C64 dirt cheap.
      </p>

      <p>
        And when you turned it on, you would see:
      </p>

      <pre class="c64">

      **** COMMODORE 64 BASIC V2 ****

   64K RAM SYSTEM 38911 BASIC BYTES FREE

   READY.









      </pre>

      <p>
        And you couldn't do much compared to today's
        machines, but what you did was all yours, baby!
      </p>

    </section>
    
    <section id="footer"><p>
      This page was last updated on September 30, 2020. This
      page is a part of the <a href="index.html">Retrocomputing
      Section</a>, which is part of
      <a href="../../index.html">Meadhbh Hamrick's Web
        Site</a>.      
    </p></section>
  </body>
</html>
